#!/usr/bin/env python3
"""
Compare ellipse detection results between MATLAB and C++ implementations.

This script reads the CSV files generated by both implementations and
compares the detected ellipses, reporting differences.
"""

import sys
import csv
from math import sqrt, fabs

# Threshold for considering partial matches as acceptable
# 80% means at least 80% of ellipses from the larger set must match
# This allows for minor differences in edge case detections while still
# validating that the implementations are largely consistent
PARTIAL_MATCH_THRESHOLD = 0.8

def normalize_angle(angle):
    """Normalize angle to [0, 360) range."""
    while angle < 0:
        angle += 360
    while angle >= 360:
        angle -= 360
    return angle

def angle_difference(a1, a2):
    """Calculate minimum angular difference considering 180-degree symmetry."""
    # Ellipse has 180-degree symmetry, so angle and angle+180 are equivalent
    diff1 = abs(a1 - a2)
    diff2 = abs(a1 - (a2 + 180))
    diff3 = abs((a1 + 180) - a2)
    return min(diff1, diff2, diff3, 360 - diff1)

def read_ellipses(filename):
    """Read ellipse parameters from CSV file."""
    ellipses = []
    try:
        with open(filename, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                ellipse = {
                    'x': float(row['x']),
                    'y': float(row['y']),
                    'a': float(row['a']),
                    'b': float(row['b']),
                    'phi': normalize_angle(float(row['phi_degrees']))
                }
                ellipses.append(ellipse)
    except FileNotFoundError:
        print(f"Error: File not found: {filename}")
        return None
    except Exception as e:
        print(f"Error reading {filename}: {e}")
        return None
    
    return ellipses

def ellipse_distance(e1, e2):
    """Calculate distance between two ellipses."""
    # Position difference
    pos_diff = sqrt((e1['x'] - e2['x'])**2 + (e1['y'] - e2['y'])**2)
    
    # Axes difference (consider a/b swap due to orientation)
    axes_diff1 = sqrt((e1['a'] - e2['a'])**2 + (e1['b'] - e2['b'])**2)
    axes_diff2 = sqrt((e1['a'] - e2['b'])**2 + (e1['b'] - e2['a'])**2)
    axes_diff = min(axes_diff1, axes_diff2)
    
    # Angle difference
    angle_diff = angle_difference(e1['phi'], e2['phi'])
    
    return {
        'position': pos_diff,
        'axes': axes_diff,
        'angle': angle_diff
    }

def match_ellipses(matlab_ellipses, cpp_ellipses, threshold=10.0):
    """Match ellipses between MATLAB and C++ results."""
    # Weights for combining different distance metrics into total distance
    # Position is weighted most heavily (1.0) as it's the most reliable indicator
    # Axes differences are less critical (0.1 weight) due to fitting variations
    # Angle differences are also less critical (0.1 weight) and symmetric at 180°
    POSITION_WEIGHT = 1.0
    AXES_WEIGHT = 0.1
    ANGLE_WEIGHT = 0.1
    
    matches = []
    unmatched_matlab = list(range(len(matlab_ellipses)))
    unmatched_cpp = list(range(len(cpp_ellipses)))
    
    # Find best matches
    for i, e_matlab in enumerate(matlab_ellipses):
        best_match = None
        best_distance = float('inf')
        
        for j in unmatched_cpp:
            e_cpp = cpp_ellipses[j]
            dist = ellipse_distance(e_matlab, e_cpp)
            total_dist = (dist['position'] * POSITION_WEIGHT + 
                         dist['axes'] * AXES_WEIGHT + 
                         dist['angle'] * ANGLE_WEIGHT)
            
            if total_dist < best_distance and dist['position'] < threshold:
                best_distance = total_dist
                best_match = j
        
        if best_match is not None:
            matches.append((i, best_match))
            unmatched_cpp.remove(best_match)
            unmatched_matlab.remove(i)
    
    return matches, unmatched_matlab, unmatched_cpp

def compare_ellipses(matlab_file, cpp_file, verbose=True):
    """Compare ellipse detection results."""
    print("=" * 70)
    print("Ellipse Detection Comparison: MATLAB vs C++")
    print("=" * 70)
    
    # Read ellipses from both files
    matlab_ellipses = read_ellipses(matlab_file)
    cpp_ellipses = read_ellipses(cpp_file)
    
    if matlab_ellipses is None or cpp_ellipses is None:
        return False
    
    print(f"\nMATLAB detected: {len(matlab_ellipses)} ellipses")
    print(f"C++ detected:    {len(cpp_ellipses)} ellipses")
    
    # Match ellipses
    matches, unmatched_matlab, unmatched_cpp = match_ellipses(matlab_ellipses, cpp_ellipses)
    
    print(f"\nMatched ellipses: {len(matches)}")
    print(f"Unmatched in MATLAB: {len(unmatched_matlab)}")
    print(f"Unmatched in C++: {len(unmatched_cpp)}")
    
    # Display matched ellipses
    if matches and verbose:
        print("\n" + "=" * 70)
        print("Matched Ellipses Comparison:")
        print("=" * 70)
        print(f"{'#':<4} {'Parameter':<12} {'MATLAB':<15} {'C++':<15} {'Diff':<10}")
        print("-" * 70)
        
        max_diffs = {
            'x': 0, 'y': 0, 'a': 0, 'b': 0, 'phi': 0
        }
        
        for idx, (m_idx, c_idx) in enumerate(matches, 1):
            e_matlab = matlab_ellipses[m_idx]
            e_cpp = cpp_ellipses[c_idx]
            
            print(f"\nEllipse {idx}:")
            for param in ['x', 'y', 'a', 'b']:
                diff = abs(e_matlab[param] - e_cpp[param])
                max_diffs[param] = max(max_diffs[param], diff)
                print(f"     {param:<12} {e_matlab[param]:<15.4f} {e_cpp[param]:<15.4f} {diff:<10.4f}")
            
            # Handle angle specially
            angle_diff = angle_difference(e_matlab['phi'], e_cpp['phi'])
            max_diffs['phi'] = max(max_diffs['phi'], angle_diff)
            print(f"     {'phi':<12} {e_matlab['phi']:<15.4f} {e_cpp['phi']:<15.4f} {angle_diff:<10.4f}")
        
        print("\n" + "=" * 70)
        print("Maximum Differences:")
        print("=" * 70)
        print(f"Position (x, y):  {max(max_diffs['x'], max_diffs['y']):.4f} pixels")
        print(f"Axes (a, b):      {max(max_diffs['a'], max_diffs['b']):.4f} pixels")
        print(f"Angle (phi):      {max_diffs['phi']:.4f} degrees")
    
    # Display unmatched ellipses
    if unmatched_matlab:
        print("\n" + "=" * 70)
        print("Unmatched ellipses in MATLAB:")
        print("=" * 70)
        for idx in unmatched_matlab:
            e = matlab_ellipses[idx]
            print(f"  {idx+1}: x={e['x']:.2f}, y={e['y']:.2f}, "
                  f"a={e['a']:.2f}, b={e['b']:.2f}, phi={e['phi']:.2f}°")
    
    if unmatched_cpp:
        print("\n" + "=" * 70)
        print("Unmatched ellipses in C++:")
        print("=" * 70)
        for idx in unmatched_cpp:
            e = cpp_ellipses[idx]
            print(f"  {idx+1}: x={e['x']:.2f}, y={e['y']:.2f}, "
                  f"a={e['a']:.2f}, b={e['b']:.2f}, phi={e['phi']:.2f}°")
    
    # Summary
    print("\n" + "=" * 70)
    print("Summary:")
    print("=" * 70)
    
    if len(matches) == len(matlab_ellipses) == len(cpp_ellipses) and len(matches) > 0:
        print("✓ All ellipses matched between MATLAB and C++")
        print("✓ Detection results are consistent")
        return True
    elif len(matches) > 0:
        match_ratio = len(matches) / max(len(matlab_ellipses), len(cpp_ellipses))
        print(f"⚠ Partial match: {match_ratio*100:.1f}% of ellipses matched")
        return match_ratio > PARTIAL_MATCH_THRESHOLD
    else:
        print("✗ No ellipses matched between implementations")
        return False

def main():
    matlab_file = "tests/test_data/matlab_results.csv"
    cpp_file = "tests/test_data/cpp_results.csv"
    
    # Allow override from command line
    if len(sys.argv) > 1:
        matlab_file = sys.argv[1]
    if len(sys.argv) > 2:
        cpp_file = sys.argv[2]
    
    verbose = True
    if len(sys.argv) > 3 and sys.argv[3] == "--quiet":
        verbose = False
    
    success = compare_ellipses(matlab_file, cpp_file, verbose)
    
    print("\n" + "=" * 70)
    if success:
        print("Test PASSED: MATLAB and C++ implementations produce consistent results")
        return 0
    else:
        print("Test FAILED: Significant differences between MATLAB and C++")
        return 1

if __name__ == "__main__":
    sys.exit(main())
