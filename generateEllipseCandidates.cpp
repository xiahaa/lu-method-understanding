#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <limits.h>
#include <float.h>
#include <iostream>

#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/opencv.hpp"

#include "datatype.h"
#include "utils.hpp"
#include "image.hpp"
#include "elsd.hpp"
#include "group_forming.hpp"
#include "gen_init_set.hpp"
#include "clustering.hpp"
#include "gradient.hpp"

//#ifdef __APPLE__
//#else
#ifdef MEX_COMPILE
    #include "mex.h"
#endif
//#endif



using namespace cv;

/*------------------------------------------------------------------------------------------------*/
/**
my code,Alan Lu
??????
img  : ?????????????????????double?????????,?????????Y*X??????????????????????????????????????????????????????
X    : ???????????????columns
Y    ??????????????????rows
??????
n_out: lsd????????????????????????????????????n???return???????????????n?????????????????????double?????????????????????8*n??????8?????????????????????x1,y1,x2,y2,dx,dy,width,polarity
reg_img: ?????????????????????????????????int??????????????????reg_y*reg_x,???????????????????????????????????????????????????(1,2,3,...n),????????????0???????????????????????????.
         ???????????????int * region_img,???????????? &region_img,?????????????????????????????????????????????????????????NULL??????
reg_x  : ?????????????????????columns,??????????????????NULL??????
reg_y  : ?????????????????????rows,??????????????????NULL??????
*/
double * mylsd(int * n_out, double * img, int X, int Y, int ** reg_img, int * reg_x, int * reg_y)
{
   /* LSD parameters */
  double scale = 0.8;       /* Scale the image by Gaussian filter to 'scale'. */
  double sigma_scale = 0.6; /* Sigma for Gaussian filter is computed as
                                sigma = sigma_scale/scale.                    */
  double quant = 2.0;       /* Bound to the quantization error on the
                                gradient norm.                                */
  double ang_th = 22.5;     /* Gradient angle tolerance in degrees.           */
  double log_eps = 0.0;     /* Detection threshold: -log10(NFA) > log_eps     */
  double density_th = 0.7;  /* Minimal density of region point2is in rectangle. */
  int n_bins = 1024;        /* Number of bins in pseudo-ordering of gradient
                               modulus.                                       */

  return LineSegmentDetection( n_out, img, X, Y, scale, sigma_scale, quant,
                               ang_th, log_eps, density_th, n_bins,
                               reg_img, reg_x, reg_y );
}







//==========================================END=======================================================================
/**
?????????
prhs[0]: ?????????????????????????????????????????????imgy x imgx
prhs[1]: ?????????????????????1 canny; 2 sobel
prhs[2]: ???????????????????????????
?????????
plhs[0]: ??????????????????(xi,yi,ai,bi,phi_i)', 5 x m
plhs[1]: ?????????????????????imgy x imgx???????????????????????? edgepix_n. ????????????0 ?????? 255
plhs[2]: ?????????????????????????????????????????? 2 x edgepix_n, (cos(theta_rad),sin(theta_rad))'...
plhs[3]: ?????????????????????imgy x imgx
*/
/*
compile???
mex generateEllipseCandidates.cpp -IF:\OpenCV\opencv2.4.9\build\include -IF:\OpenCV\opencv2.4.9\build\include\opencv -IF:\OpenCV\opencv2.4.9\build\include\opencv2 -LF:\OpenCV\opencv2.4.9\build\x64\vc11\lib -IF:\Matlab\settlein\extern\include -LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib
*/
//======================================MEX function==================================================================
//#ifdef MEX_COMPILE
void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
   if(nrhs!=3)
       mexErrMsgIdAndTxt( "MATLAB:revord:invalidNumInputs","One input required.");
   else if(nlhs > 4)
       mexErrMsgIdAndTxt( "MATLAB:revord:maxlhs","Too many output arguments.");
   uchar * inputimg = (uchar*)mxGetData(prhs[0]);
   int imgy,imgx;
   int edge_process_select = (int)mxGetScalar(prhs[1]);//?????????????????????1 canny; 2 sobel
   int specified_polarity  = (int)mxGetScalar(prhs[2]);//1,????????????????????????????????????; -1??????????????????; 0?????????????????????????????????
   imgy = (int)mxGetM(prhs[0]);
   imgx = (int)mxGetN(prhs[0]);
   double *data=(double*)malloc(imgy*imgx*sizeof(double));//?????????????????????????????????????????????????????????
   for(int c=0;c<imgx;c++)
   {
       for(int r=0;r<imgy;r++)
       {
           data[c+r*imgx]=inputimg[r+c*imgy];
       }
   }
   int n;//????????????
   //int new_n;
   std::vector<std::vector<int>> groups;
   double * coverages;
   int * reg;
   int reg_x;
   int reg_y;
   double* out=mylsd(&n, data,imgx,imgy,&reg,&reg_x,&reg_y);
   groupLSs(out,n,reg,reg_x,reg_y,&groups);//????????? done.
   free(reg); //????????????
   calcuGroupCoverage(out,n,groups,coverages);//??????????????????????????????, done

   mexPrintf("The number of output arc-support line segments: %i\n",n);
   mexPrintf("The number of arc-support groups:%i\n",groups.size());
   /*int groups_t = 0;
    for (int i = 0; i<groups.size(); i++)
    {
    groups_t+= groups[i].size();
    }
    printf("Groups' total ls num:%i\n",groups_t);*/

   image_double angles;
   if(edge_process_select == 1)
       calculateGradient2(data,imgx,imgy,&angles); //version2, sobel; version 3 canny
   else
       calculateGradient3(data,imgx,imgy,&angles); //version2, sobel; version 3 canny
   PairGroupList * pairGroupList;
   double distance_tolerance = 2;//max( 2.0, 0.005*min(angles->xsize,angles->ysize) ); // 0.005%*min(xsize,ysize)
   double * candidates; //????????????
   double * candidates_out;//????????????????????????
   int  candidates_num = 0;//??????????????????
   //rejectShortLines(out,n,&new_n);
   pairGroupList = getValidInitialEllipseSet(out,n,&groups,coverages,angles,distance_tolerance,specified_polarity);
   if(pairGroupList != NULL)
   {
       mexPrintf("The number of initial ellipses???%d \n",pairGroupList->length);
       generateEllipseCandidates(pairGroupList, distance_tolerance, candidates, &candidates_num);
       mexPrintf("The number of ellipse candidates: %d \n",candidates_num);

       plhs[0] = mxCreateDoubleMatrix(5,candidates_num,mxREAL);
       candidates_out = (double*)mxGetPr(plhs[0]);
       //???????????????(xi,yi,ai,bi,phi_i)', 5 x candidates_num, ???????????????candidates_out???
       memcpy(candidates_out,candidates,sizeof(double)*5*candidates_num);

       freePairGroupList(pairGroupList);
       free(candidates);
   }
   else
   {
       mexPrintf("The number of initial ellipses???%i \n",0);
       double *candidates_out;
       plhs[0] = mxCreateDoubleMatrix(5,1,mxREAL);
       candidates_out = (double*)mxGetPr(plhs[0]);
       candidates_out[0] = candidates_out[1] = candidates_out[2] = candidates_out[3] = candidates_out[4] = 0;
   }
   uchar *edgeimg_out;
   unsigned long edge_pixels_total_num = 0;//???????????????
   double *gradient_vec_out;
   plhs[1] = mxCreateNumericMatrix(imgy,imgx,mxUINT8_CLASS,mxREAL);
   edgeimg_out = (uchar*)mxGetData(plhs[1]);
   //???????????????????????????edgeimg_out???
   //???????????????????????????gradient_vec_out???
   unsigned long addr,g_cnt = 0;
   for ( int c = 0; c < imgx; c++ )
       for ( int r = 0; r < imgy; r++)
       {
           addr = r*imgx+c;
           if(angles->data[addr] == NOTDEF)
               edgeimg_out[c*imgy+r] = 0;
           else
           {
               edgeimg_out[c*imgy+r] = 255;//??????????????????????????????
               //------------------------------------------------
               edge_pixels_total_num++;
           }
       }
   mexPrintf("edge pixel number: %i\n",edge_pixels_total_num);
   //??????edge_pixels_total_num x 2 ?????????????????????????????????????????????????????????????????????matlab?????????
   plhs[2] = mxCreateDoubleMatrix(2,edge_pixels_total_num,mxREAL);
   gradient_vec_out = (double*)mxGetPr(plhs[2]);
   for ( int c = 0; c < imgx; c++ )
       for ( int r = 0; r < imgy; r++)
       {
           addr = r*imgx+c;
           if(angles->data[addr] != NOTDEF)
           {
               gradient_vec_out[g_cnt++] = cos(angles->data[addr]);
               gradient_vec_out[g_cnt++] = sin(angles->data[addr]);
           }
       }
   //---------------------------------------------------------------------
   //???????????????????????????
   if(nlhs == 4)
   {
       Mat ls_mat = Mat::zeros(imgy,imgx,CV_8UC1);
       for ( int i = 0; i<n ; i++)//draw lines
       {
           Point2d p1(out[8*i],out[8*i+1]),p2(out[8*i+2],out[8*i+3]);
           line(ls_mat,p1,p2,Scalar(255,0,0));
       }
       if(candidates_num > 0)//draw ellipses
       {
           for ( int i = 0; i<candidates_num; i++)
               ellipse(ls_mat,cv::Point((int)candidates_out[i*5],(int)candidates_out[i*5+1]),cv::Size(candidates_out[i*5+2],candidates_out[i*5+3]),candidates_out[i*5+4]*180/M_PI,0,360,(Scalar(255,0,0)),1);
       }
       plhs[3] = mxCreateDoubleMatrix(imgy,imgx,mxREAL);
       double * ls_img_out = (double*)mxGetPr(plhs[3]);
       //memcpy(ls_out_mat,ls_mat.data ,sizeof(unsigned char)*M*N);
       for (int i = 0; i<imgx; i++)
           for (int j = 0; j<imgy;j++)
               ls_img_out[i*imgy+j]=ls_mat.data[j*imgx+i];
   }
   //---------------------------------------------------------------------
   //?????????free??????????????????????????????????????????????????????????????????
   free(data);
   free(coverages);
   free(out);
   free_image_double(angles);
}

//#else
// #ifdef __APPLE__
// //
// //  main.c
// //  lu
// //
// //  Created by xiao.hu on 2020/5/19.
// //  Copyright ?? 2020 xiao.hu. All rights reserved.
// //

// int main(int argc, const char * argv[]) {
//     // insert code here...
//     printf("Hello, World!\n");

//     std::string images_folder = "/Volumes/document/fore-end/ellipse_detection/thirdparty/detection/High-quality-ellipse-detection-master/pics";
// //    "/Volumes/document/fore-end/ellipse_detection/data/test_data";
//     std::string out_folder = images_folder;
//     std::vector<std::string> names;
//     names.push_back(images_folder+"/"+"27.jpg");
//     //glob(images_folder + "Lo3my4.*", names);

//     for (const auto& image_name : names)
//     {
//         std::string name = image_name.substr(image_name.find_last_of("/") + 1);
//         name = name.substr(0, name.find_last_of("."));

//         Mat3b image = imread(image_name);
//         Size sz = image.size();

//         // Convert to grayscale
//         Mat1b gray;//1b is one byte
//         cvtColor(image, gray, CV_BGR2GRAY);

//         int edge_process_select = 2;
//         int specified_polarity = 0;

//         int imgy = gray.rows;
//         int imgx = gray.cols;

//         uchar *ptr = (uchar*)gray.data;

//         double *data=(double*)malloc(imgy*imgx*sizeof(double));//?????????????????????????????????????????????????????????
//         for(int c=0;c<imgx;c++)
//         {
//             for(int r=0;r<imgy;r++)
//             {
//                 data[c+r*imgx]=ptr[c+r*imgx];
//             }
//         }

//         int n;//????????????
//         //int new_n;
//         std::vector<std::vector<int>> groups;
//         double * coverages;
//         int * reg;
//         int reg_x;
//         int reg_y;
//         double* out=mylsd(&n, data,imgx,imgy,&reg,&reg_x,&reg_y);
//         groupLSs(out,n,reg,reg_x,reg_y,&groups);//????????? done.
//         free(reg); //????????????
//         calcuGroupCoverage(out,n,groups,coverages);//??????????????????????????????, done

//         printf("The number of output arc-support line segments: %i\n",n);
//         printf("The number of arc-support groups:%i\n",groups.size());

//         image_double angles;
//         if(edge_process_select == 1)
//             calculateGradient2(data,imgx,imgy,&angles); //version2, sobel; version 3 canny
//         else
//             calculateGradient3(data,imgx,imgy,&angles); //version2, sobel; version 3 canny
//         PairGroupList * pairGroupList;
//         double distance_tolerance = 2;//max( 2.0, 0.005*min(angles->xsize,angles->ysize) ); // 0.005%*min(xsize,ysize)
//         double * candidates; //????????????
//         double * candidates_out;//????????????????????????
//         int  candidates_num = 0;//??????????????????
//         //rejectShortLines(out,n,&new_n);
//         pairGroupList = getValidInitialEllipseSet(out,n,&groups,coverages,angles,distance_tolerance,specified_polarity);
// //        double *candidates_out = NULL;
//         if(pairGroupList != NULL)
//         {
//             printf("The number of initial ellipses???%i \n",pairGroupList->length);
//             generateEllipseCandidates(pairGroupList, distance_tolerance, candidates, &candidates_num);
//             printf("The number of ellipse candidates: %i \n",candidates_num);

// //            plhs[0] = mxCreateDoubleMatrix(5,candidates_num,mxREAL);
// //            candidates_out = (double*)mxGetPr(plhs[0]);
//             candidates_out = (double *)malloc(sizeof(double)*5*candidates_num);
//             if (candidates_out == NULL)
//             {
//                 std::cout << "initialize candidates_out failed!"<<std::endl;
//                 assert(1);
//             }
//             //???????????????(xi,yi,ai,bi,phi_i)', 5 x candidates_num, ???????????????candidates_out???
//             memcpy(candidates_out,candidates,sizeof(double)*5*candidates_num);

//             freePairGroupList(pairGroupList);
//             free(candidates);
//         }
//         else
//         {
//             printf("The number of initial ellipses???%i \n",0);
// //            double *candidates_out;
// //            plhs[0] = mxCreateDoubleMatrix(5,1,mxREAL);
// //            candidates_out = (double*)mxGetPr(plhs[0]);
// //            candidates_out[0] = candidates_out[1] = candidates_out[2] = candidates_out[3] = candidates_out[4] = 0;
//         }
// //        uchar *edgeimg_out;
//         unsigned long edge_pixels_total_num = 0;//???????????????
//         double *gradient_vec_out;
// //        plhs[1] = mxCreateNumericMatrix(imgy,imgx,mxUINT8_CLASS,mxREAL);
// //        edgeimg_out = (uchar*)mxGetData(plhs[1]);
//         //???????????????????????????edgeimg_out???
//         //???????????????????????????gradient_vec_out???
//         cv::Mat edgeimg_out(imgy,imgx,CV_8UC1);
//         unsigned long addr,g_cnt = 0;
//         for ( int c = 0; c < imgx; c++ )
//             for ( int r = 0; r < imgy; r++)
//             {
//                 addr = r*imgx+c;
//                 if(angles->data[addr] == NOTDEF)
//                     edgeimg_out.data[addr] = 0;
//                 else
//                 {
//                     edgeimg_out.data[addr] = 255;//??????????????????????????????
//                     //------------------------------------------------
//                     edge_pixels_total_num++;
//                 }
//             }
//         cv::imshow("edge detection res", edgeimg_out);
//         printf("edge pixel number: %i\n",edge_pixels_total_num);
//         //??????edge_pixels_total_num x 2 ?????????????????????????????????????????????????????????????????????matlab?????????
// //        plhs[2] = mxCreateDoubleMatrix(2,edge_pixels_total_num,mxREAL);
// //        gradient_vec_out = (double*)mxGetPr(plhs[2]);
// //        for ( int c = 0; c < imgx; c++ )
// //            for ( int r = 0; r < imgy; r++)
// //            {
// //                addr = r*imgx+c;
// //                if(angles->data[addr] != NOTDEF)
// //                {
// //                    gradient_vec_out[g_cnt++] = cos(angles->data[addr]);
// //                    gradient_vec_out[g_cnt++] = sin(angles->data[addr]);
// //                }
// //            }
//         //---------------------------------------------------------------------
//         //???????????????????????????
// //        if(nlhs == 4)
//         {
//             Mat ls_mat = Mat::zeros(imgy,imgx,CV_8UC3);
//             image.copyTo(ls_mat);
//             for ( int i = 0; i<n ; i++)//draw lines
//             {
//                 Point2d p1(out[8*i],out[8*i+1]),p2(out[8*i+2],out[8*i+3]);
//                 line(ls_mat,p1,p2,Scalar(255,0,0));
//             }
//             if(candidates_num > 0)//draw ellipses
//             {
//                 for ( int i = 0; i<candidates_num; i++)
//                     ellipse(ls_mat,cv::Point((int)candidates_out[i*5],(int)candidates_out[i*5+1]),cv::Size(candidates_out[i*5+2],candidates_out[i*5+3]),candidates_out[i*5+4]*180/M_PI,0,360,(Scalar(0,255,0)),1);
//             }

//             cv::imshow("seg detection res", ls_mat);
//             cv::waitKey(0);
// //            plhs[3] = mxCreateDoubleMatrix(imgy,imgx,mxREAL);
// //            double * ls_img_out = (double*)mxGetPr(plhs[3]);
//             //memcpy(ls_out_mat,ls_mat.data ,sizeof(unsigned char)*M*N);
// //            for (int i = 0; i<imgx; i++)
// //                for (int j = 0; j<imgy;j++)
// //                    ls_img_out[i*imgy+j]=ls_mat.data[j*imgx+i];
//         }
//         //---------------------------------------------------------------------
//         //?????????free??????????????????????????????????????????????????????????????????
//         free(data);
//         free(coverages);
//         free(out);
//         free_image_double(angles);

//         //        Mat3b resultImage = image.clone();
//         //        yaed.DrawDetectedEllipses(resultImage, ellsYaed);
//         //
//         //        imwrite(out_folder + name + ".png", resultImage);
//         //
//         //        imshow("Yaed", resultImage);
//         //        waitKey();
//         //
//         //
//         //        int yghds = 0;
//     }

//     return 0;
// }
// #endif
